## 进程管理

系统内有一个祖宗进程，首先会调用fork函数调用子进程，根据fork的返回值，如果返回值是子进程的进程编号，当前执行的是父进程，如果返回0说明执行的子进程，这时会调用execve分离出一个子进程，这时候，子进程才真正脱离父进程，fork才生效了，生出了一个独立的子进程。

父进程如何了解子进程运行情况？系统调用waitpid，接受子进程编号作为参数，从而让父进程知道子进程的运行状况。

进程中断：
- ctrl + c
- 非法访问其它进程的内存
- 硬件中断
- kill进程

## 内存管理

进程运行过程需要内存，这个内存是进程运行起来后才分配给进程的。

内存分类：

- 存放代码段 code segment
- 存放其它数据 堆 Heap
- 数据段 Data Segment

进程内分配到的内存一般有几个GB，32位的内存也能有4GB。

如何分配内存：
- 数量小，用brk放在堆的旁边
- 数量大，用mmap,重新划出一个区域

## 文件管理

一切皆文件：
- 打印到控制台是stdout文件
- 打印到磁盘的文件
- 进程启动加载的yml, properites是文件
- 启动的进程是二进制文件
- 查看进程也是放在一个proc文件里
- 网络通信的socket也是文件
- 访问外部设备，设备也是文件
- 一个进程输出作为另一个进程的输入，管道也是文件

## 进程通信

一个进程msgset创建一个消息队列，msgsnd发送信息到消息队列，另一个进程mssrcv读取消息队列。

进程间共享内存。shmget创建共享内存，另一个进程shmat把共享内存映射到自己的进程内存中。

## 网络管理

socket与socket之间的通信。

## 系统调用的代理

C编程会调用Glibc，GLibc再调用操作系统的API。
- Glibc和系统API一一对应， open对应sys_open
- Glibc和系统API一对多对应，printf对应sys_open, sys_nmap, sys_write, sys_close
- Glibc和系统API多对一对应，malloc, colloc, free对应sys_brk


