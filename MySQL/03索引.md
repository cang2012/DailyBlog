通过索引让查询速度更快。

```
create table T(
	id int not null, primary key, auto_increment
	k int not null,
	name varchar(16),
	index(k)) engine=InnoDB;
```

主键索引，也叫聚簇索引clustered index。

非主键索引，也叫二级索引secondary index

每个engine索引背后的数据结构和算法都不相同。

## 如果索引用哈希表来实现  ##

哈希表就是key-value键值对。其原理是根据key通过哈希算法得到一个具体位置，就可以得到具体位置上的value。然后每个位置上会存一个链表。

这样做的好处是：key不是递增的，增加key会很快，适用于一些等值查询的场景。比如redis, memcached。

坏处是：做区间查询慢。

## 如果索引用有序数组来实现 ##

有序数组Id自增，查询时间复杂度是O(logn),就像数组一样，插入的效率不高，适合于一些静态存储，即不需要经常插入数据的场景。

为什么实际很少用二叉树作为索引的模型呢？

因为二叉树分的层次比较多，磁盘读写次数比较多，而多叉树的情况就好很多。

多叉树层次比较少，磁盘读写次数少。多叉树的子节点是从小到大排列的。

当然MySQL有很多engine,各种engine的模型都不一样，其它模型有跳表，LSM树。

## 如果索引用二叉搜索树来实现 ##

二叉树是左边的子节点比父节点小，右边比父节点大。查询时间复杂度是O(logn)，而为了保证二叉树的平衡，更新节点的时间复杂度是O(logn)。

> 主键索引和非主键索引的区别？

主键索引的子节点存储的是每行的值。非主键索引的子节点存储的是主键的id值，所以，用非主键索引字段查询会比主键字段查询多了一个回表操作。

> 为什么要用自增主键？

如果不用自增主键，需要在记录之间插入行，逻辑上会挪动后面的位置，效率不高。另外还存在页分裂的问题，当一个页数据满了会分裂成两个页，这样空间利用率会降低到大约20%；而如果删除数据可能会让相邻两页合并。

> 可以用业务字段作为自增主键吗？

假设用身份证号作为主键索引，非主键索引存储的是主键索引的值，身份证号大约20个字节，而一般存储int32,是4个字节，存储int64是8个字节。这种情况下用身份证号作为主键索引就不合适了。

但是，如果有些情况只用一个唯一的主键索引，就可以用业务字段作为自增主键。

## 覆盖索引 ##

创建一张表。

```
create table T (
	ID int Primary Key, 
	k int NOT NULL DEFAULT 0,
	s varchar(16) NOT NULL DEFAULT '',
	index k(k)
) egnine = InnoDB

insert into T values (100,1,'aa')(200,2,'bb')(300,3,'cc')(500, 5, 'ee')(600,6,'ff')(700,7,'gg')
```

会创建主键索引树和k索引树。

现在来一个查询语句
```
select * from T where k between 3 and 5;
```

- 来到索引树k,找到3，对应的ID是300
- 回到主键索引树，找到ID是300，这个过程叫回表
- 来到索引树k，找到5，对应ID是500
- 回到主键索引树，找到ID是500，再次回表
- 回到索引树k,找到6，不符合条件(也就是在索引树查找的时候会一直查到不满足条件的那个)

以上在索引树k上执行了3次查询记录，即在InnoDB引擎内执行了3次查询记录，而对MySQL的服务层来说，它只拿到了2条符合条件的记录，它的扫描次数是2次。

以上，回表的效率不是最好的。改变搜索条件：

```
select ID from T where k between 3 and 5;
```

由于在k索引树上就包含了ID值，这次就不用回表了。这里的k索引被称为`覆盖索引`，`覆盖索引`包含要搜索的字段，可以减少回表的次数，提高效率。

## 联合索引 ##

创建一个联合索引

```
(name, age)

"李四"，20 ： ID1
"王五"，10 ： ID2
"张六"，20 ： ID3
"张三"，10 ： ID4
"张三"，10 ： ID5
"张三"，20 ： ID6
```

执行`name='站三'`可以用上这里的联合索引。

执行`name like '张%'`，也可以用上这里的联合索引。这里会遵信一个`最左原则`，会找符合'张%'的联合索引键值，然后找某个索引键值中符合'张%'条件的最左边的几个字符串。

如果可以通过调整联合字段的顺序可以少维护一个索引，那就值得做。如果某个索引占用空间比较大，可以考虑联合索引和单个索引结合的方式。

联合索引在不同版本中的表现可能是不一样的，不如：

```
select * from tuser where name like '张%' and age=10 and ismale=1
```
在MySQL5.6之前，通过索引找到ID值，再回表。但到了MySQL5.6引入了`下推优化index condition pushdown`的机制，对索引包含的字段先做判断，过滤掉不满足条件的记录，减少回表次数。

## 其它问题 ##

重建索引
--有时候会因为删除出现页分裂，导致数据也有空洞，重建索引，把数据按顺序插入，页面利用率高，索引更紧凑，更省空间。重建k索引合理，重建主键索引不合理，因为会有表的重建。