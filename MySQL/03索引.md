通过索引让查询速度更快。

```
create table T(
	id int not null, primary key, auto_increment
	k int not null,
	name varchar(16),
	index(k)) engine=InnoDB;
```

主键索引，也叫聚簇索引clustered index。

非主键索引，也叫二级索引secondary index

每个engine索引背后的数据结构和算法都不相同。

## 如果索引用哈希表来实现  ##

哈希表就是key-value键值对。其原理是根据key通过哈希算法得到一个具体位置，就可以得到具体位置上的value。然后每个位置上会存一个链表。

这样做的好处是：key不是递增的，增加key会很快，适用于一些等值查询的场景。比如redis, memcached。

坏处是：做区间查询慢。

## 如果索引用有序数组来实现 ##

有序数组Id自增，查询时间复杂度是O(logn),就像数组一样，插入的效率不高，适合于一些静态存储，即不需要经常插入数据的场景。

为什么实际很少用二叉树作为索引的模型呢？

因为二叉树分的层次比较多，磁盘读写次数比较多，而多叉树的情况就好很多。

多叉树层次比较少，磁盘读写次数少。多叉树的子节点是从小到大排列的。

当然MySQL有很多engine,各种engine的模型都不一样，其它模型有跳表，LSM树。

## 如果索引用二叉搜索树来实现 ##

二叉树是左边的子节点比父节点小，右边比父节点大。查询时间复杂度是O(logn)，而为了保证二叉树的平衡，更新节点的时间复杂度是O(logn)。

> 主键索引和非主键索引的区别？

主键索引的子节点存储的是每行的值。非主键索引的子节点存储的是主键的id值，所以，用非主键索引字段查询会比主键字段查询多了一个回表操作。

> 为什么要用自增主键？

如果不用自增主键，需要在记录之间插入行，逻辑上会挪动后面的位置，效率不高。另外还存在页分裂的问题，当一个页数据满了会分裂成两个页，这样空间利用率会降低到大约20%；而如果删除数据可能会让相邻两页合并。

> 可以用业务字段作为自增主键吗？

假设用身份证号作为主键索引，非主键索引存储的是主键索引的值，身份证号大约20个字节，而一般存储int32,是4个字节，存储int64是8个字节。这种情况下用身份证号作为主键索引就不合适了。

但是，如果有些情况只用一个唯一的主键索引，就可以用业务字段作为自增主键。


