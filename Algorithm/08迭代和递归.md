回眸2018年，注定是极其特殊的一年。在此之前，也就是2017年底，所有关于痛点、梦想、奋斗、资本、家庭、团队的林林总总在猝不及防间写下剧本，从故事的主角到主角的故事，其中滋味自知。2018年我只做了一件事，这件事注定会为我未来的发展定下基调。而现在，偶然想起过去十年的创业历程，内心更多的是坦然和平静，这段经历让我看到了世界本来的样子。迈过2018，如今我已从那段故事里走了出来，我对过去的自己说：“善良、单纯有时候未必换来好的结果，因为世界自有它的算法。但是请你务必保持真我，只有真我，才会不辜负所爱，才有可能在时间的长河中留下些许痕迹”。站在2019年初，最要感谢的是那份温暖，那是患难与共时爱情的光芒，那是错愕困顿时的不离不弃，那是萍水相逢的滴水之恩，那是身处绝境时心中永不磨灭的太阳。They say time heals everything. 

2018年经济遇冷资本寒冬。微软说，你问我未来世界科技将如何演变，对不起我也不知道，但我知道产业数据比算法更重要。腾讯说，我要调整组织架构，互联网的下半场是产业互联网。也有人说，在未来，你要么是数据，要么是算法。

最近看算法比较多，越来越觉得算法是人类文明进化的一种底层思维。本篇要说的是迭代(Iteration)和递归(Recursion)，从定义上来讲迭代是从一个已知变量得到新变量的过程,递归则是函数调用自己的过程。

吴军在那篇"一张名片写下人类文明"中，它把`1+1=2`放在了第一位。这个公式的神奇之处在于：1通过迭代变成了2，从而定义了数字2。而如日中天的AlphGo，尽管击败了李世石、柯洁，它的核心仍是一个超大的人工神经网络，它能做的事情就是对各种数据进行聚类，这些类具有共性，并且依此判断其它数据是否属于这一类，但是人工智能始终做不到定义一个概念。人类正是通过迭代、因果逻辑的推导来了解世界的确定性，通过质能转换公式`E=mc^2`发明了核武器，人类把1克物质全部转化成能量，就相当于22000吨TNT炸药爆炸所发出的能量。人类也通过信息熵的公式了解世界的不确定性，并在此基础上建立了现代通信。

**一个简单的例子：在第一个格子中放1，第二个格子中放2，第三个格子中放4，第63个格子放多少？**

第二个格子是第一个格子的2倍，第三个格子是第二个格子的2倍，以此类推。

```
public class Iterative1
{
    public static long GetNumOfGrids(int maxGrid)
    {
        long result = 0;
        long currentNumInGrid =0;

        //第一个格
        currentNumInGrid = 1;
        result += currentNumInGrid;

        //第二格开始
        for(int i = 2; i <= maxGrid; i++)
        {
            currentNumInGrid *= 2;
            result += currentNumInGrid;
        }

        return result;
    }
}
```

以上，从第一格开始，总是能从上一个格子迭代出下一个格子的数字，就像爬楼梯，一步一步走，总能到达上一层。

**再来一例：给你两个一模一样的玻璃球，两个球到达一定的高度掉到地上就会坏掉，在1层和100层楼之间，如何用最少的次数求出让玻璃球摔碎的楼层？**

首先直觉是从第一层开始，一层一层地试，直到找到那个楼层。如果运气好，第一层就试出来，那还比较好；如果答案是99层呢？人类的聪明之处在于面对现实世界的问题，总能找到最适合的方法。所以，也可以10层10层地试，比如到了60层一个玻璃球坏了，那答案是在50和60之间，再从50-60之间依次试，这样不出20次就能得到答案。

以上的过程还是迭代，但是采取了先粗调再精调的思想，这可以让我们少做事情。二分法也体现了先粗调再精调的思想。

**使用二分法的例子：计算某个大于1的正整数n的平方根？**

这个问题可以等价为：一个数的平方等于n。

如果说通过迭代让我们可以找到确定或非确定结果的话，等价思想则为我们思考问题提供了新的角度。一个复杂的问题总是可以等价成若干简单的问题；谷歌的多国语言机器翻译等价成信息学问题，从信息学的角度解决了机器翻译问题；人类一开始想模仿鸟类自己飞行，到后来等价成通过发明飞行器实现自己的飞行梦想......这样的例子举不胜举，就拿我自己来说，这一年，我通过迭代和等价思想解决了很多棘手问题。

以上的问题，如果写方法，有一个参数是n。加一个表示精度的参数，如果找到符合条件的值，并且小于精度，就返回值。最后来一个代表最大从哪个数开始找的参数。

```
public class Iterative2
{
    //n 表示大于1的正整数n
    //deltaThreshhold 表示最终接收的精度
    //maxTry表示最大从哪个数开始
    public static double GetSquireRoot(int n, double deltaThreshold, int maxTry)
    {
        if(n <= 1){ return -1.0; }

        dobule min = 1.0;
        double max = (double)n;
        for(int i = 0; i < maxTry; i++)
        {
            double middle = (min + max) /  2;
            double square = middle * middle;
            
            var delta = Math.Abs((square/n) - 1);
            if(delta <= deltaThreshold)
            {
                return middle;
            }
            else
            {
                if(square > n){
                    max = middle;
                }
                else
                {
                    min = middle;
                }
            }
        }

        return -2.0;
    }
}
```

**再来一个二分法例子：在一组字符串集合中找出一个字符串。**

```
public class Iterative3
{
    public static bool Search(string[] arr, string wordToFind)
    {
        if(arr == null) return false;
        if(arr.Length == 0) return false;

        int left = 0;
        int right = arr.Length -1;
        while(left <= right)
        {
            int middle = (left + right) / 2;
            if(arr[middle] == wordToFind)
            {
                return true;
            }
            else
            {
                if(arr[middle].CompareTo(wordToFind) > 0)
                {
                    right = middle -1;
                }
                else
                {
                    left = middle +1;
                }
            }
        }
        return false;
    }
}
```

体现先粗调再精调思想的例子有很多。 最先进的手术机器人用的电机一开始速度很快，是粗调，越接近目标，转速越慢，变成精调；机器学习是不断调整数学模型参数的过程，直到达到最佳收敛点；机器学习中的很多算法包含了从粗调到精调的过程。比如K-均值算法k-means clustering, PageRank的马尔科夫链Markov chain,梯度下降法Gradient descent等，首先粗调，最终来到一个局部的最优解；本田的NSX超级跑车有4个发动机，一个是传统的汽油发动机提供动力，相当于粗调，一个电动发动机提供起跑瞬间的加速动力，相当于精调，还有另外两个提供加速和减速动力，也算精调。

先粗调再精调相比一步一步的迭代，确实效率高了很多。但是在有些情况下，比如迭代过程复杂时，用递归更合适。递归是特殊的迭代，递归的过程不是由前一步得到后面一步，而是：如果前一步的公式和算法成立，那下一步使用该公式和算法也成立。

**一个用递归解决的问题：有四种面额的钱：1元、2元、5元、10元，如果想得到10元，共有几种给发呢？**

如果用迭代的方式。第一次拿1元，第二次拿2元，第三次拿5元，第四次拿2元；也可以第一次拿5元，第二次拿2元，第三次拿2元，第四次拿1元；还可以第一就拿10元。其中的过程非常复杂，这种情况下用迭代就像走迷宫，多半会把自己绕晕。

过程比较复杂，从结果上来看，可以把问题等价为：拿钱的人最终得到了10元，给钱的人只要把10元给出去就意味着这件事的结束。所以给钱的人有一个账本，账本上写着我要给出去10元。当给出2元，账本记为我还要给出去8元。以此类推，当账本记为我还要给出去0元时，事情就终止。这里的0元就是递归的终止条件。而每次账本的算法是一样的，都要算还有多少钱需要给出去。这就是典型的可以用递归解决的问题，有递归的终止条件，过程包含了相同的算法。

```
public class DiGuiHelper
{
    public static long[] rewards = {1, 2, 5, 10};
    public static void GetPossibilities(long left, List<long> tempResult)
    {
        if(left == 0)
        {
            Console.WriteLine(string.Join(',', result));
            return;
        }
        else if(left < 0)
        {
            return;
        }
        else
        {
            for(int i = 0; i < rewards.Length; i++)
            {
                List<long> currentResult = new List<long>(result);
                currentResult.Add(rewards[i]);
                GetPossibilities(left -  rewards[i], currentResult);
            }
        }
    }
}
```

以上，我把当下的心境放在了这篇不起眼的文章里，其实并不希望让很多人看到，很多亲身经历是无法用言语表达的，我想，通过文字也算是一种释放、释然吧。当然，迭代、等价思想、粗调和精调、二分法都是在解决工程问题时比较底层的思想和方法。












