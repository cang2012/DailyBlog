复杂度描述了数据规模的增长和效率之间的关系。在估算复杂度的时候，常常忽略常数、低阶、系数。并且有几个原则：


- 执行次数最多原则：关注循环执行次数最多的那段代码。
- 加法原则：多段代码，关注量级最大的那段代码。
- 乘法原则：嵌套代码，复杂度为嵌套内外代码复杂度的乘积。

```
int cal(int n){
	//1*unit_time
	int sum = 0;
	//2n*unit_time
	for(int i=1; i <= n; i++){
		sum = sum + i;
	}
	return sum;
}
```

以上，时间复杂度大致是：2n+1,忽略常数和系数，时间复杂度是O(n)。

```
int cal(int n){
	int sum =0;
	for(int i=0; i <n; i++){
		for(int j =0; j < n; j++){
			sum = sum + i*j;
		}
	}
	return sum;
}
```
以上，根据乘法原则，时间复杂度是O(n^2)。

```
int cal(n){
	int sum1 = 0;
	for(int p=0; p < 100; p++){
		sum1 = sum1 + p;
	}

	int sum2=0;
	for(int q=0; q < n; q++){
		sum2 = sum2 + q;
	}

	int sum3=0;
	for(int i=0; i<n; i++){
		for(j=0;j<n;j++){
			sum3 = sum3 + i*j;
		}
	}
}
```
以上，根据加法原则，多段代码的复杂度关注量级最高的那段，时间复杂度是O(n^2)。

> 最低效的时间复杂度是指数阶O(2^n)和阶乘阶(n!)。随着n越来越大执行时间会急剧增加。

> O(1)常量阶。执行代码的时间不随n的增大而增大。只要算法中不存在循环语句、递归语句，即使有成千上万行代码，时间复杂度也是O(1)。

```
int i = 0;
int j = 8;
int sum =  i +  j;
```

> O(logn)对数阶。

``
int i = 1;
while(i <= n){
	i = i * 2;
}
```

> O(n)线性阶。

> O(nlogn)线性对数阶。

> O(n^2)平方阶，立方阶......K次方阶。

> 空间复杂度。时间复杂度的全称是渐进时间复杂度asymptotic time complexity,相对应的，空间复杂度的全称是渐进空间复杂度asymptotic space complexity，表示存储空间与数据规模之间的增长关系。空间复杂度没有像时间复杂度那么多，基本就有O(1), O(n), O(n^2)。

```
void print(int n){
	int[] arr = new int[n];
	for(int i=0; i < n; i++){
		arr[i] = i * i;
	}
}
```

以上，变量arr的存储空间和n有关系，所以这里的空间复杂度是O(n)。

> 以上，时间或者空间随着数据规模的增长存在着某种程度的确定关系。在时间复杂度方面还有其它的视角或者维度，那就是当条件不同时所体现的时间复杂度。主要有：最好情况时间复杂度(the best case time complexity)、最坏情况时间复杂度(the worst case time complexity)、平均情况时间复杂度(the average case time complexity)、均摊时间复杂度(amortized time complexity)。

```
//在数组长度是n的array中查找x元素所在的位置
int find(int[] array, int n, int x){
	int pos = -1;
	for(int i = 0; i < n; i++){
		if(array[i]==x){
			pos = i;
			//找到了就跳出循环
			break;
		}
	}
	return pos;
}
```

以上，如果x正好是数组中的第一个元素，时间复杂度是O(1)，这个是最好情况时间复杂度；如果x没找到，时间复杂度是O(n)，这个是最坏情况时间复杂度。

> 说到平均情况复杂度，说到平均，就是每一种可能代码执行的次数之和除以总的可能性次数。

说到上面的情况，查找变量x在数组中的位置，有n+1种情况。n种找到的情况，1个找不到x元素的情况。每一种可能性代码执行的次数之和是：1+2+...+n+n，第二个n是指找不到x元素也要执行n次。所以这里的平均情况复杂度是：1+2+...+n+n/n=1,算下来就是n(n=3)/2(n+1),这里的平均情况时间复杂度是O(n)。

> 上面这种分析方法没有把概率考虑进来，如果把概率考虑进来呢？假设，x在或者不在数组种的概率都是1/2，x出现在每个位置上的概率是1/n，这样，根据概率的乘法法则，x在任意位置的概率是1/2n。

上面的情况，把概率考虑进来，就是：

1*1/2n + 2*1/2n+...+n*1/2n + n*1/2(这里的最后一个位置就是找不到x的情况，只有1次，就没有x出现在每个位置上的概率这一说了)

然后再除以n=1,得到的结果是：3n+1/4。

> 这时候，平均情况复杂度叫作加权平均复杂度或者期望时间复杂度。

> 最后，来说说均摊时间复杂度。有时候，代码执行的时候会出现有限的极端情况，既然极短情况出现执行的次数很少，就把这种情况均摊到其它情况中去。

```
int[] array = new int[n];
int count = 0;

void insert(int val){
	//只有当指针位置在最后一个数组元素上的收
	if(count == array.length){
		int sum = 0;
		for(int i = 0; i < array.length; i++){
			sum = sum = array[i];
		}
		arrray[0] = sum;
		count =1;
	}

	array[count] = val;
	++count;
}
```

以上，均摊时间复杂度是O(1)，因为最后一次耗时最多，把最后一次的耗时均摊到前面的n-1次操作上。可见，对均摊时间复杂度来说，最后一次的执行和前面的执行是有时序上的关系的。
