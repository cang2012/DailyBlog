散列表，Hash Table，具有按照下标随机访问数据的特性，可以看作是数组扩展。用的时候，不管是插入、删除、查询，很多时候时间复杂度是O(1)。不过其内部实现，真的是精彩丰呈。

内部拿到一个key，经过散列函数得到散列值，也叫Hash值，这个Hash值就是数组的下标了，然后根据这个小标找到相应的值。

不同的key经过散列函数或者说Hash函数后，可能会得到相同的值，因为其本质就是求模的过程，就像一个星期有7天，总会碰上相同的余数。得到相同的散列值，叫散列冲突。即使和安全有关的MD5、SHA、CRC等哈希算法也都会存在散列冲突的可能。冲突的原因在于数组的空间永远都是有限的。

如何解决散列冲突呢？

一种是开放寻址，open addressing,如果出现散列冲突，重新找一个空闲位置，通过线性探测linear probing找到空闲位置。当通过hash函数得到的散列值，即数组的下标被占用了，就从当前位置开始依次往后找，直到找到为止。还可以有二次线性探测，quatratic probing,这里的二次不是说第二次探测，而是说是二次方。如果说线性探测的步长是hash(key)+0, hash(key)+1, hash(key)+2,那么二次线性探测的步长是hash(key)+0, hash(key)+1<sup>2</sup>, hash(key)+2<sup>2</sup>。还有一种方式是经过多重散列，就是经过多个hash函数得到hash值。

一种方式是链表chaining。每一个hash值对应数组中的一个桶bucket，或者槽slot，然后每个槽后面对应链表，有些事双链表，有些事红黑树，这个槽对应的实现很灵活，目的就是换到最快的时间。

不管怎样，当散列表空间位置越来越少，散列的冲突概率越来越大。定义了一个概念叫"装载因子load factor"，这是一个阈值，当达到这个阈值就会进行扩容。扩容也很有讲究的，有些扩容后就会进行一次数据搬运，把原来散列表的数据重新经过hash计算放到新的散列表中，这样当插入一个数据又会进行扩容时间上会很长。改良的做法是扩容，申请新的散列表空间，但不急着进行数据搬运，而是等到每次往新的散列表插入数据的时候，再从原先的散列表中拿到一个值放到新的散列表里。这种**均摊思想**很重要。

来看一个来自，比如word文档里如何知道一个词拼写错误给提示呢？比如每个单词10个字母，1个字母1个字节，10个字母10个字节，20万个单词就是200万个字节，相当于2MB，即使20MB，内存也可以承受。于是把所有的字母预先加载到内存，放到一个散列表Hash Table里，每次输入的单词就是key,拿着这个key经过hash函数得到散列值，就是数组的下标，如果根据这个小标能找到就不会有报错提示，如果找不到就给出错误提示。


hash table,散列表设计的不好也会受到散列碰撞攻击。其原理是把很多数据通过hash函数后散列到同一个数组槽里，这样数组链表里的数据越来越多，消耗CPU或线程资源越来越多，系统就无法响应其它请求，拒绝服务了Dos。

所以设计散列表就要考虑很多，比如使散列函数生成的值随机均匀分布，根据key的长度特点来设计方法，散列表的大小什么时候扩容，这些都需要考虑。

设计散列表，一种是通过数据分析法，就是先研究key的特点然后给出方法，比如090208表示一个参赛选手的编号，前两个表示年级，中间两个表示班级，最后两个表示编号，这种情况根据最后两个编号得到散列值。

设计散列表装载因子也是很重要的方面。装载因子越大，元素越多，空间越少，散列冲突概率越大，没有频繁插入或静态基本不变的已知数据还好说。但是如果是动态散列表，需要动态扩容，常申请一个2倍的空间，把原来的数据搬到新的散列表，原来散列表的存储位置变了，重新计算每个数据的存储位置。有的情况下还有进行缩容的。


在用链表法解决散列冲突时，会存储指针，这个比较耗内存，但如果存储对象很大，远远大于每个指针4个字节大小，那指针占用的内存就可以忽略了。

真正设计的时候，链表法对应的数据结构可以变化，可以红黑树，可以是双链表，非常灵活。