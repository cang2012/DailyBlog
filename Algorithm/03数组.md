> 数组就是相同类型得数据连续的内存空间。

横向看数据结构家族，数组属于`线性表Linear List`这个类别，因为数据只有前和后两个方向，在这个类别里的其它数据结构还有队列、栈、链表等；`非线性表Linear List`的数据结构包括：二叉树、堆、图等。当插入数组元素，本质是把值放到某一块内存地址上。当查找数组元素，本质是找到内存地址上的那个值。

> 查找数组元素的复杂度是多少呢？

很多人都会觉得是O(n)，但是，还可以用二叉树的方式查找，复杂度就是O(logn)。

> 当访问一个数组元素，是如何找到内存地址呢？

这里有一条固定的公式：

```
a[i]_address = base_address + i * data_type_size;
```

理解数组的的下标为什么从0开始，从上面这条公式就可得到答案。数组的下标可以理解为是为了找到内存地址而存在的偏移量，数组中的第一个元素就位于基地址，所以第一个元素的下标为0。如果下标从1开始，查找内存地址的公式就变成：

```
a[i]_address = base_address + (i-1) * data_type_size;
```

以上相比前者多做了一次减法。总的来说，下标从0开始这个习惯被大多数人接收，当然也有语言下标是从1开始的。

以上值得说的一点是data_type_size, 比方说int类型，占4个字节，1个字节8个位，int类型占了32位。位是针对二进制来说的，通常我们用字节来表示空间大小，比如`1M=1024B`。还可以引出的一个话题是不同的字符集对应不同的字节。比如ACII码，中文有2个字节，应为有1个字节；比如Unicode码，中文和英文都是2个字节。

> 插入数组元素。

当在一个有n个元素的数组中的K位置插入x。

如果这个位置在数组的第一位，最好情况复杂度是O(1)；如果这个位置在数组的最后一位，最坏情况复杂度是O(n);平均情况复杂度是1+2+...+n/n=O(n)。假设这个位置在数组中间的某个位置，当x插入到k位置，k=1以后的所有元素需要往后挪一位。

> 删除数组元素。

当在一个有n个元素的数组中的K位置删除元素。

如果这个位置在数组的第一位，最好情况复杂度是O(1)；如果这个位置在数组的最后一位，最坏情况复杂度是O(n);平均情况复杂度是1+2+...+n/n=O(n)。假设这个位置在数组中间的某个位置，当K位置的元素从数组中移出，从K+1位置以后的所有元素需要往前挪一位。

如果需要删除多个数组元素，可以在这些元素上打一个删除标记，最后一次性删除，复杂度就是O(1)。JVM的垃圾回收，Entity Framwork的_db.SaveChanges()都是这样的机制。

> 数组的越界。

模拟一个越界的情况。

```
int main(int argc, char* argv){
	int i = 0;
	int arr[3] = {0};
	for(; i <=3, i++){
		arr[i]=0;
		printf("");
	}
	return 0;
}
```

以上，数组有3个元素，但循环了4次，到第四次的时候，也就是给arr[3]赋值的时候，超出了那块连续的内存地址空间，于是就把值赋给了变量i所在的内存地址，又由于i是对这个地址的引用，于是i就变成了0，循环遍历再一次开始。

数组的越界在高级语言中是会检查的，但在诸如C这样的语言中，不会自动检查，有时候这种越界问题很难看出来。

