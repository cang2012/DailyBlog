Redis的有序集合就是用跳表来实现的。

二分查找通常通过数组来实现，因为数组是一块连续的内存空间，满足二分查找的随机查找特性。

跳表是一种链表加多级索引的动态数据结构，也可以理解成特殊的二分查找。

跳表的时间复杂度怎么算呢？


先算索引层级的复杂度。原始链表有n个结点，一级索引有n/2个结点，二级索引有n/4个结点，k级索引有n/2<sup>k</sup>个结点，最终有2个结点，也就是最终n/2<sup>k</sup>=2, 如果索引层级有h级的话n/2<sup>h</sup>=2, h+1=log<sub>2</sub>n，即h=log<sub>2</sub>n-1，如果把原始链表加上去的话,h=log<sub>2</sub>n。

再算原始链表遍历的复杂度，水平方向遍历m个结点，所以时间复杂度是O(mlogn)，由于m是一个常数，通常不超过3个结点，综合起来，跳表查找的时间复杂度是O(logn)。这和二分查找一样是非常快的，如果数据量少的情况下，甚至比O(1)还要来得快。

从空间角度看。因为要存储索引的层级，跳表实际上是用空间换时间。空间复杂度如何计算呢？存储原始链表的n个结点，存储一级索引的n/2个结点，存储k级索引的n/2<sup>k</sup>个结点，所有的加起来就是n-2,所以空间复杂度是O(n)。在实际开发中，层级索引所占的空间相比结点对象经常是可以忽略的。

插入时间复杂度如何计算呢？插入时间复杂度和查找时间复杂度是一样的也是O(n)。

删除的时间复杂度如何计算呢？找到要删除的结点，并找到该结点之前的结点，操作指向就可以，所以，插入的时间复杂度也是O(n)。

索引层是需要动态更新的。当不断往跳表里插入数据，如果不更新索引，会出现原始链表的两个结点之间的结点增多，极端情况下，会退化成单链表。跳表通常是通过手动操作更新索引，如果链表中的结点多，索引的结点相应也要多，其内部是通过随机函数保持平衡，这个随机函数的设计也很有讲究。

在插入、删除、查找方面，跳表的表现和红黑树相当，但在按区间查找方面跳表表现更好。另外跳表的代码容易实现、可读性强、可操作性也可以，因为可以通过手动调整索引结构。红黑树的历史比跳表长，在很多Map类型中都会用红黑树。

