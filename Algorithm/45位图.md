位图，Bitmap,可以很大程度上节省空间。看一个场景：

> 搜索引擎爬虫根据链接爬取，很多时候不同的页面会存在相同的链接，如何对这些链接去重呢？还需要考虑：
> 1. 快速添加url
> 2. 快速查询url
> 3. 内存效率

首先想到的是用散列表、红黑树、跳表来做。

估算一下：假设有10亿个url, 每个url有64个字节，那么：10 0000 0000 * 64 = 64 000 000 000 = 64GB,再加上还要存储链表指针，可能需要100GB。对于大多数计算机而言是否无法承受的，可以找来20台服务器，100GB/20=5GB,每台服务器只需处理5GB的数据，找一个8GB内存的机器就可以。

如果用散列表来做，插入和查询的时间复杂度都是O(1)，那散列表是最适合的吗？其实不是的。时间复杂度是从宏观上来看的，表示执行时间随着数据规模变化的趋势，如果落到微观上，哪怕系数之间的有10关系，那也是10的时间啊。

通过散列表还有几个问题：
- 从效率上来看。链表中的结点在内存中是不连续的，无法一下子加载到CPU，无法利用CPU的高速缓存
- 从时间上来看。链表中的节点存储url的长度比较长，字符串匹配花费的时间比较长

用位图能很大程度上提升效率，布隆过滤器Bloom Filter就是在位图基础上的改善。假设有这么一个问题：

> 有1000万个已知的整数存储在某个地方，现在输入一个整数，这个整数的范围在1到1亿之间，如何判断输入整数是否存在于1000万之中呢？

用位图这么做：

- 位图是特殊的散列表
- 申请一个大小为1亿，数据类型为布尔类型的数组
- 已知的1000万数据，以整形数为下标，数值类型为布尔存放在这个数组中，比如5,array[5]=true,表示这个数组中5号位有值
- 这时，输入一个查询数k, 如果array[k] = true,说明k就在1000万之中
- 不过，很多高级语言的布尔类型有个问题，就是布尔类型是1个字节，也就是有8个位，是否可以用二进制位表示true呢？
- 估算一下：已知的1000万数据，如果是32位整型数，也就是4个字节，1000 0000 * 4 = 4000 0000 = 40 * 10<sup>6</sup>=40MB;而1亿二进制， 1 0000 0000 / 8 = 12 000 000 = 12 MB。内存空间大大减少。

所以用位图来解决文章一开始的问题，不仅添加快、查询快，而且还省空间。


布隆过滤器Bloom Filter解决的数量级更大，比如：

> 已经存在1000万数据，要判断某个数值范围在1-10亿之间的数是否已经存在？


布隆过滤器Bloom Filter大致是这么解决的：

- 还是使用1亿个二进制大小的位图
- 现在有10亿个数，通过哈希函数得到hash code再除以1亿取模，落到1亿之间
- 这里会出现散列冲突，如何解决呢？
- 一种方式是设计复杂一点的、随机的散列函数。
- 布隆过滤器B采用多个散列函数。
- 先把这已知的1000万个数，分别通过多个哈希函数存在于散列表的多个槽里
- 对于输入数据，通过同样的多个哈希函数判断是否存在于散列表的多个槽里

布隆过滤器有一定的误差，不过在很多场景中这种误差是可以忽略的。

