> 有数量级为几十万的客户记录，每个客户都有其积分，现在要做这么几件事：
> 1. 根据客户ID快速查找、更新、删除积分
> 2. 查找某个积分区间内的所有客户
> 3. 查找某个排序位上的客户
> 4. 查找某个排序区间里的所有客户


对于1，需要一个散列表Hash List。对散列表来说，当key经过哈希函数，不同的key可能得到相同的hash code, 因为作为key的字符串虽然无限，但计算机的整型是有数值范围的；还有，不同的key即使得到不同的hash code，但也有可能最终得到相同的索引，因为hash code最后要除以一个整数，得到的模就是索引，所以模有可能是相同的；当不同的key经过哈希函数得到hash code, 再通过hash code除以整数取模，可能会得到相同的索引，也就是把不同的key对应的值放在了同一个索引位置，这就是collision冲突，如何解决冲突呢？有很多方式，最常用的用链表来解决，每个索引位置上存储一个链表结构。当然还有会通过二叉树、红黑树来解决冲突的方式。

对于2, 需要通过跳表来做，Skip List。跳表最重要的两个特点是： 1. 集合已经是排好序的；2. 会创建多层作为索引。所以，把所有的客户按积分排好序，然后创建多级索引，当需要查找某个积分区间的所有客户，实际是在跳表的某些层级的某些节点之间查找。

对于3和4，需要在跳表的索引节点上加一个字段，存储到下一个索引节点经历的节点数。