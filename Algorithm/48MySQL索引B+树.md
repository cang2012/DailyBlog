MySQL索引是用B+树实现的，也叫多叉树。实现这样一种工业级的多叉树需要考虑很多情况，其中性能、空间、时间是很重要的方面。

如果用散列表，散列表支持快速查询、插入，查询时间复杂度是O(1)，但不支持区间快速查找。

如果用平衡二叉树，时间复杂度O(logn)，而且还是从小到大的数据排列，但也不支持区间快速查找。

如果用跳表，在链表基础上的多层索引，时间复杂度O(logn)，支持快速查询、插入、删除，也支持按区间快速查找, 在索引层级这个角度，B+树和跳表很相似，但B+树是在二叉树基础上演化而来的。

> B+树的节点不存储数据，只作为索引，把每个叶子节点串在一条链表上。比如要查找一个区间，拿到区间的起始值，在树中找到比这个起始值大的节点，再顺着链表往后遍历，当发现链表中的节点大于区间终点值，遍历结束。

来看内存使用。如果一个表的索引有1亿个节点，每个节点16个字节， 内存占用16 0000 0000 = 10<sup>9</sup>，即大概在1GB这个数量级，如果有10张表呢？内存肯定承受不了。

所以，MySQL是把索引存在了磁盘上，而磁盘的读写效率并不高，在计算机的存储中，CPU内的寄存器是最快的但同时容量也最小，接着就是三级高速缓存也够快容量也比寄存器大一点，再往后就是内存了，再往后是磁盘IO主线上的存储设备，越往外层空间越大但读写效率越低。内存访问速度在纳秒级，磁盘访问速度在毫秒级。

MySQL把索引存放在磁盘上，用空间换时间，可是时间是如何尽量少呢？要尽量减少与磁盘交互的次数。在这种解决思路下，诞生了B+树，也就是一个父结点有超过2个的子节点，但每层的子节点越多，树的高度越低，IO读写次数越少。比如，对于一亿条索引，用m叉树，如果m=100,最多读写磁盘3次。这样就解决了减少读写磁盘次数的问题。

B+树插入数据的过程不快：

- m叉树的具体数值是根据页的大小提前设计好的
- 即每个层级子节点数量最多有m个
- 在写入数据过程中可能导致某个层级的节点数超过m个
- 也就是，节点的数量超过页容量
- 将这个需要插入的节点分裂成两个节点
- 这样对于上层父结点来说，它的子节点数量可能超过m个了
- 再将父节点分裂成两个节点
- 这种级联反应由下到上，一直影响到根节点
- 正是因为要时刻保证B+树索引是一个m叉树，所以会导致插入数据时间相对长

B+树删除数据也不快：

- 也需要更新索引节点
- 频繁地删除索引节点，导致某个父结点下子节点数量非常少
- 这就影响了索引效率
- 设置一个阈值，大概在m/2
- 如果某个层级的节点数量大于m/2
- 就和兄弟节点合并
- 合并和的节点数量可能大于m
- 然后像插入数据一样，节点分裂成两个节点，由下而上一直到根节点



